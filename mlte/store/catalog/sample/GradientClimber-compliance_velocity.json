{
    "header": {
        "identifier": "GradientClimber-compliance_velocity",
        "creator": "admin",
        "created": 1763413972,
        "updater": null,
        "updated": 1763413972,
        "catalog_id": "sample"
    },
    "tags": [
        "Reinforcement Learning"
    ],
    "quality_attribute": "Compliance",
    "code": "# ## 2d. Evidence - Compliance - Velocity\n# \n# Evidence collected in this section checks for velocity complience in the Gradient Climber Example.  The model is complient if the velocity never exceeds 0.05.\n\n# ### Initialize MLTE Context\n# \n# MLTE contains a global context that manages the currently active _session_. Initializing the context tells MLTE how to store all of the artifacts that it produces. This import will also set up global constants related to folders and model to use.\n\n# Sets up context for the model being used, sets up constants related to folders and model data to be used.\nfrom session import *\n\n\n# ### Set up scnario test case\n\nfrom mlte.negotiation.artifact import NegotiationCard\n\ncard = NegotiationCard.load()\nqa = 3\nprint(card.quality_scenarios[qa])\n\n\n# **A Specific test case generated from the scenario:**\n# \n# **Data and Data Source:**\tVehicle state (position and velocity) from sensors (or approximated by simulation engine in development)\n# \n# **Measurement and Condition:**\t|\ud835\udc63\ud835\udc52\u210e\ud835\udc56\ud835\udc50\ud835\udc59\ud835\udc52_\ud835\udc63\ud835\udc52\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc56\ud835\udc61\ud835\udc66|<0.05 at all times\n# \n# **Context:**\tNormal Operation\n\n# ### Helper Functions\n\n# Define basic constants\nNUM_TRIALS = 100\nMEASURE_NAME = \\\"gradient climber velocity accuracy\\\"\n\n\nimport numpy as np\nimport gymnasium as gym\n\n\nenv = gym.make(\\\"MountainCar-v0\\\", render_mode=\\\"rgb_array\\\")\nstate, info = env.reset()\n\n\n# Discretize the state space (position, velocity)\nposition_bins = np.linspace(-1.2, 0.6, 20)\nvelocity_bins = np.linspace(-0.07, 0.07, 20)\n\n# Q-table initialization\nq_table = np.load(os.path.join(DATA_DIR, \\\"mountain_car.npy\\\"))\n\n\n# Discretize the continuous state (position and velocity)\ndef discretize_state(state):\n    position, velocity = state\n    position_idx = (\n        np.digitize(position, position_bins) - 1\n    )  # Position bin index\n    velocity_idx = (\n        np.digitize(velocity, velocity_bins) - 1\n    )  # Velocity bin index\n    return position_idx, velocity_idx\n\n\n# Epsilon-greedy action selection\ndef choose_action(state):\n    position_idx, velocity_idx = discretize_state(state)\n    return np.argmax(q_table[position_idx, velocity_idx])\n\n\n# ## Compliance\n\ndef evaluate_action(state, action):\n    \\\"Return 1 if this is the expected action, return 0 if it is the wrong move, and -1 as an error condition\\\"\n    position, velocity = state\n    if np.abs(velocity) >= 0.05:\n        return np.bool(False)\n    else:\n        return np.bool(True)\n\n\ndef test_velocity_compliance():\n    done = False\n    test_results = []\n    states = []\n\n    for i in range(NUM_TRIALS):\n        state, info = env.reset()\n        done = False\n        actions = []\n\n        while not done:\n            # Random action selection\n            action = choose_action(state)\n\n            # Take the action and get the next state, reward, done flag, and info\n            next_state, reward, done, truncated, info = env.step(action)\n\n            result = evaluate_action(state, action)\n            if result == True:\n                test_results.append(1)\n            elif result == False:\n                test_results.append(0)\n            # Update the state for the next iteration\n            state = next_state\n\n        print(f\\\"Completed trial {i}\\\")\n\n    return test_results\n\n\nfrom mlte.evidence.types.array import Array\nfrom mlte.measurement.external_measurement import ExternalMeasurement\n\n# Evaluate accuracy, identifier has to be the same one defined in the TestSuite.\nposition_compliance_measurement = ExternalMeasurement(\n    MEASURE_NAME, Array, test_velocity_compliance\n)\nevidence = position_compliance_measurement.evaluate()\n\n# Inspect value\nprint(evidence)\n\n# Save to artifact store\nevidence.save(force=True, parents=True)\n",
    "description": "The model receives a position and velocity input from <source> during normal operations. Regardless of input, the model will not produce output values that cause the vehicle to exceed the legal speed limit set in the operational configuration.",
    "inputs": "Initial random start position",
    "output": "Log with 1 for velocity within limits, and 0 for out-of-limits"
}